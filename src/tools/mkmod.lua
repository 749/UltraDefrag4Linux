#!/usr/local/bin/lua
--[[
  mkmod.lua - builds a module according to the specified .build file.
  Copyright (c) 2007-2018 Dmitri Arkhangelski (dmitriar@gmail.com).

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
--]]

--[[
  Synopsis: lua mkmod.lua <filename>
  Note: The script requires BUILD_ENV and UD_ROOT environment variables to be set.

  Notes for C programmers: 
    1. the first element of each array has index 1
    2. only nil and false values are false, all others including 0 are true

  If some library exports functions of __stdcall calling convention
  a *mingw.def file must be presented; it must contain names 
  decorated by at signs and number of bytes needed to pass all 
  the parameters on a 32-bit machine.
--]]

nativedll = 0
src, rc, includes, libs = {}, {}, {}, {}
files, resources = {}, {}
cpp_files = 0
prec_header = 0

-- files which names contain these patterns will be
-- included as dependencies to MinGW makefiles
rsrc_patterns = { "%.ico$", "%.bmp$", "%.manifest$" }

mingw_cmd = "mingw32-make --no-builtin-rules -f Makefile.mingw"
sdk_cmd = "nmake.exe /NOLOGO /S /f Makefile.winsdk"

-- WinSDK backend
function produce_sdk_makefile()
    local f = assert(io.open(".\\Makefile.winsdk","w"))
    
    f:write("# DON'T EDIT THIS FILE MANUALLY, IT'S BEEN ")
    f:write("AUTOMATICALLY GENERATED BY THE MKMOD.LUA ")
    f:write("SCRIPT\n\n")
    
    f:write("OUTPATH = ", outpath, "\n")
    f:write("LIBPATH = ", libpath, "\n")
    f:write("OBJPATH = ", objpath, "\n\n")
    
    f:write("TARGET = $(OUTPATH)\\", target_name, "\n\n")
    
    f:write("ALL: $(OUTPATH) $(LIBPATH) $(OBJPATH) $(TARGET)\n\n")

    f:write("$(OUTPATH):\n\t@if not exist $(OUTPATH) mkdir $(OUTPATH)\n\n")
    f:write("$(LIBPATH):\n\t@if not exist $(LIBPATH) mkdir $(LIBPATH)\n\n")
    f:write("$(OBJPATH):\n\t@if not exist $(OBJPATH) mkdir $(OBJPATH)\n\n")
    
    f:write("CFLAGS = /nologo /W3 /D \"WIN32\" /D \"NDEBUG\" /D \"_MBCS\"")
    f:write(" /D \"USE_WINSDK\" /D \"_CRT_SECURE_NO_WARNINGS\"")

    if os.getenv("OFFICIAL_RELEASE") then
        f:write(" /D \"OFFICIAL_RELEASE\"")
    end
    if os.getenv("ATTACH_DEBUGGER") == "1" then
        f:write(" /D \"ATTACH_DEBUGGER\"")
    end
    if os.getenv("SEND_CRASH_REPORTS") == "1" then
        f:write(" /D \"SEND_CRASH_REPORTS\"")
    end

    f:write(" /GS- /Gd")

    if arch == "i386" then
        f:write(" /arch:SSE2")
    end

    if arch == "ia64" then
        -- optimization for ia64 is not available:
        -- the compiler stucks with the message:
        -- error loading dll 'sched.dll': dll not found
        f:write(" /Od")
    elseif arch == "amd64" then
        -- optimization for x64 is not available,
        -- because it leads to application crashes:
        -- http://support.microsoft.com/en-us/kb/2280741
        f:write(" /Od")
    else
        -- enable optimization for official releases only
        -- as it slows down compilation significantly
        if os.getenv("OFFICIAL_RELEASE") then
            f:write(" /O2")
        end
    end

    if cpp_files ~= 0 then
        -- /EHsc is required by the <xlocale> header
        f:write(" /EHsc")
    end

    -- use static CRT instead of external msvcr100.dll library
    if nativedll == 0 then
        f:write(" /MT")
    end
    
    local subsystem
    if target_type == "console" then
        f:write(" /D \"_CONSOLE\"")
        subsystem = "console"
    elseif target_type == "gui" then
        f:write(" /D \"_WINDOWS\"")
        subsystem = "windows"
    elseif target_type == "dll" then
        f:write(" /D \"_CONSOLE\" /D \"_USRDLL\" /D \"")
        f:write(string.upper(name), "_EXPORTS\"")
        subsystem = "console"
    elseif target_type == "native" then
        subsystem = "native"
    end
    
    f:write("\n")
    
    f:write("RCFLAGS = /nologo /l 0x409 /d \"NDEBUG\"\n")
    
    f:write("LDFLAGS = /nologo /incremental:no")

    if nativedll ~= 0 or target_type == "native" then
        f:write(" /nodefaultlib")
    end
    
    if arch == "i386" then
        f:write(" /machine:I386")
    elseif arch == "amd64" then
        f:write(" /machine:AMD64")
    elseif arch == "ia64" then
        f:write(" /machine:IA64")
    end

    f:write(" /subsystem:", subsystem)

    if target_type == "dll" then
        if nativedll ~= 0 then
            f:write(" /entry:\"DllMain\"")
        end
        f:write(" /dll /def:", deffile)
        f:write(" /implib:$(LIBPATH)\\", name, ".lib")
    elseif target_type == "native" then
        f:write(" /entry:\"NtProcessStartup\"")
    end
    
    if target_type == "gui" and umentry == "main" then
        -- let GUI apps use main() whenever they need
        f:write(" /entry:\"mainCRTStartup\"")
    end

    f:write("\n\n")
    
    f:write("LIBS =")
    for i, v in ipairs(libs) do
        if v ~= "msvcrt" then
            f:write(" ", v, ".lib")
        end
    end
    f:write("\n\n")

    f:write("C_INCLUDE_DIRS = /I \"$(WXWIDGETS_INC2_PATH)\" /I \"$(WXWIDGETS_INC_PATH)\"\n")
    f:write("RC_INCLUDE_DIRS = /I \"$(WXWIDGETS_INC2_PATH)\" /I \"$(WXWIDGETS_INC_PATH)\"\n")
    f:write("LIB_DIRS = /LIBPATH:$(LIBPATH) /LIBPATH:\"$(WXWIDGETS_LIB_PATH)\"\n\n")

    f:write("CC = cl.exe\n")
    f:write("CXX = cl.exe\n")
    f:write("RSC = rc.exe\n")
    f:write("LD = link.exe\n\n")

    f:write("header_files: ")
    for i, v in ipairs(includes) do
        f:write("\\\n$(UD_ROOT)\\", v, "\\*.h ")
    end
    f:write("\n\n")

    f:write("resource_files: ")
    for i, v in ipairs(resources) do
        f:write("\\\n", v, " ")
    end
    f:write("\n\n")
    
    if prec_header ~= 0 then
        f:write("prec.pch: prec.h\n")
        if cpp_files ~= 0 then
            f:write("\t@$(CXX) $(CFLAGS) $(C_INCLUDE_DIRS) /Yc /c prec.cpp")
        else
            f:write("\t@$(CC) $(CFLAGS) $(C_INCLUDE_DIRS) /Yc /c prec.c")
        end
        f:write(" /Fo$(OBJPATH)\\prec-", arch, ".obj\n\n")
    end
    
    for i, v in ipairs(src) do
        local use_prec_header = 0
        if prec_header ~= 0 then
            -- to keep things simple let's use single prec.h file and
            -- include it to *.cpp files only in case of coexistence of
            -- *.cpp and *.c files
            if string.find(v,"%.cpp$") or cpp_files == 0 then
                use_prec_header = 1
            end
        end

        local outfile = "$(OBJPATH)\\" .. string.gsub(v,"%.c(.-)$","%-" .. arch .. "%.obj")
        
        f:write(outfile, ": ", v, " header_files")
        if use_prec_header ~= 0 then
            f:write(" prec.pch")
        end
        
        if string.find(v,"%.cpp$") then
            f:write("\n\t@$(CXX) $(CFLAGS) $(C_INCLUDE_DIRS)")
        else
            f:write("\n\t@$(CC) $(CFLAGS) $(C_INCLUDE_DIRS)")
        end
        
        if use_prec_header ~= 0 then
            f:write(" /Yuprec.h")
        end
        
        f:write(" /Fo", outfile, " /c ", v, "\n\n")
    end

    for i, v in ipairs(rc) do
        local outfile = "$(OBJPATH)\\" .. string.gsub(v,"%.rc","%-" .. arch .. "%.res")
        f:write(outfile, ": ", v, " header_files resource_files\n")
        f:write("\t@$(RSC) $(RCFLAGS) $(RC_INCLUDE_DIRS) /Fo", outfile, " ", v, "\n\n")
    end

    f:write("SRC_OBJS =")
    for i, v in ipairs(src) do
        f:write(" $(OBJPATH)\\" .. string.gsub(v,"%.c(.-)$","%-" .. arch .. "%.obj"))
    end
    f:write("\n\n")

    f:write("RSRC_OBJS =")
    for i, v in ipairs(rc) do
        f:write(" $(OBJPATH)\\" .. string.gsub(v,"%.rc","%-" .. arch .. "%.res"))
    end
    f:write("\n\n")
    
    -- for safety native executables should never depend on anything other
    -- than ntdll library, otherwise they might mess up the Windows boot
    -- process in case of accidental removal of libraries they depend on
    f:write("EXT_OBJS =")
    if target_type == "native" then
        f:write(" $(UD_ROOT)\\obj\\udefrag\\*-", arch, ".obj")
        f:write(" $(UD_ROOT)\\obj\\zenwinx\\*-", arch, ".obj")
    end
    f:write("\n\n")
    
    if target_type == "dll" then
        f:write("DEF_FILE = ", deffile, "\n\n")
        f:write("$(TARGET): $(DEF_FILE) $(SRC_OBJS) $(RSRC_OBJS)\n")
    else
        f:write("$(TARGET): $(SRC_OBJS) $(RSRC_OBJS)\n")
    end

    -- to build native executables we have to rename a couple
    -- of object files to avoid duplicated definitions of symbols
    if target_type == "native" then
        f:write("\t@move /Y $(UD_ROOT)\\obj\\udefrag\\entry-", arch, ".obj")
        f:write(" $(UD_ROOT)\\obj\\udefrag\\entry-", arch, ".tmp\n")
        f:write("\t@move /Y $(UD_ROOT)\\obj\\udefrag\\int64-", arch, ".obj")
        f:write(" $(UD_ROOT)\\obj\\udefrag\\int64-", arch, ".tmp\n")
    end

    f:write("\t@$(LD) $(LDFLAGS) /out:$(TARGET) $(SRC_OBJS) $(RSRC_OBJS) $(EXT_OBJS) $(LIB_DIRS) $(LIBS)\n")

    -- restore renamed object files
    if target_type == "native" then
        f:write("\t@move /Y $(UD_ROOT)\\obj\\udefrag\\entry-", arch, ".tmp")
        f:write(" $(UD_ROOT)\\obj\\udefrag\\entry-", arch, ".obj\n")
        f:write("\t@move /Y $(UD_ROOT)\\obj\\udefrag\\int64-", arch, ".tmp")
        f:write(" $(UD_ROOT)\\obj\\udefrag\\int64-", arch, ".obj\n")
    end

    f:close()
end

-- MinGW backend
mingw_rules = [[
define compile_c_source
@echo Compiling $<
@$(CC) $(CFLAGS) $(C_INCLUDE_DIRS) -c "$<" -o "$@"
endef

define compile_cpp_source
@echo Compiling $<
@$(CXX) $(CFLAGS) $(C_INCLUDE_DIRS) -c "$<" -o "$@"
endef

compile_c_header = $(compile_c_source)
compile_cpp_header = $(compile_cpp_source)

define compile_resource
@echo Compiling $<
@$(RSC) $(RCFLAGS) $(RC_INCLUDE_DIRS) -i "$<" -o "$@"
endef

define build_target
@echo Linking...
@$(LD) $(LDFLAGS) -o $(TARGET) $(SRC_OBJS) $(RSRC_OBJS) $(EXT_OBJS) $(LIB_DIRS) $(LIBS)
endef

]]

function produce_mingw_makefile()
    local f = assert(io.open(".\\Makefile.mingw","w"))

    f:write("# DON'T EDIT THIS FILE MANUALLY, IT'S BEEN ")
    f:write("AUTOMATICALLY GENERATED BY THE MKMOD.LUA ")
    f:write("SCRIPT\n\n")
    
    f:write("OUTPATH = ", outpath, "\n")
    f:write("LIBPATH = ", libpath, "\n")
    f:write("OBJPATH = ", objpath, "\n\n")
    
    f:write("TARGET = $(OUTPATH)\\", target_name, "\n\n")
    
    f:write("ALL: $(OUTPATH) $(LIBPATH) $(OBJPATH) $(TARGET)\n")
    f:write(".PHONY: ALL\n\n")

    f:write("$(OUTPATH):\n\t@if not exist $(OUTPATH) mkdir $(OUTPATH)\n\n")
    f:write("$(LIBPATH):\n\t@if not exist $(LIBPATH) mkdir $(LIBPATH)\n\n")
    f:write("$(OBJPATH):\n\t@if not exist $(OBJPATH) mkdir $(OBJPATH)\n\n")
    
    f:write("CFLAGS = -pipe  -Wall -g0")

    -- enable optimization, even for test builds, as otherwise
    -- NtQueryInformationProcess returns STATUS_DATATYPE_MISALIGNMENT
    -- somehow in winx_get_drive_type routine
    f:write(" -O2")

    if arch == "amd64" then
        f:write(" -m64")
    end
    
    if os.getenv("OFFICIAL_RELEASE") then
        f:write(" -DOFFICIAL_RELEASE")
    end
    if os.getenv("ATTACH_DEBUGGER") == "1" then
        f:write(" -DATTACH_DEBUGGER")
    end
    if os.getenv("SEND_CRASH_REPORTS") == "1" then
        f:write(" -DSEND_CRASH_REPORTS")
    end

    f:write("\n")
    
    f:write("RCFLAGS = -O COFF\n")
    
    f:write("LDFLAGS = -pipe")
    
    if target_type == "console" then
        f:write(" -Wl,--strip-all")
    elseif target_type == "gui" then
        f:write(" -mwindows -Wl,--strip-all")
    elseif target_type == "native" then
        f:write(" -nostartfiles -nodefaultlibs -Wl,--entry,")
        f:write("_NtProcessStartup\@4,--subsystem,native,--strip-all")
    elseif target_type == "dll" then
        f:write(" -nostartfiles -nodefaultlibs -shared ")
        f:write(mingw_deffile, " -Wl,--kill-at,")
        f:write("--entry,_DllMain\@12,--strip-all")
    end

    f:write("\n\n")

    f:write("LIBS =")

    local rev_libs = {}
    for i, v in ipairs(libs) do
        f:write(" -l", v)
        table.insert(rev_libs,1,v)
    end
    
    -- include libraries once again in reverse order;
    -- otherwise link with static wxWidgets libraries
    -- might fail
    for i, v in ipairs(rev_libs) do
        f:write(" -l", v)
    end
    
    f:write("\n\n")
    
    f:write("C_INCLUDE_DIRS = -I\"$(WXWIDGETS_INC2_PATH)\" -I\"$(WXWIDGETS_INC_PATH)\"\n")
    f:write("RC_INCLUDE_DIRS = -I\"$(WXWIDGETS_INC2_PATH)\" -I\"$(WXWIDGETS_INC_PATH)\"\n")
    f:write("LIB_DIRS = -L$(LIBPATH) -L\"$(WXWIDGETS_LIB_PATH)\"\n\n")

    f:write("CC = gcc.exe\n")
    f:write("CXX = g++.exe\n")
    f:write("RSC = \"$(COMPILER_BIN)windres.exe\"\n")
    if cpp_files ~= 0 then
        f:write("LD = g++.exe\n\n")
    else
        f:write("LD = gcc.exe\n\n")
    end
    
    f:write(mingw_rules)
    
    if target_type == "dll" then
        f:write("define build_library\n")
        f:write("\@echo Building import library...\n")
        f:write("\@dlltool -k --output-lib $(LIBPATH)\\lib")
        f:write(name, ".dll.a --def ", mingw_deffile, "\n")
        f:write("endef\n\n")
    end

    f:write("header_files = ")
    for i, v in ipairs(includes) do
        f:write("\\\n$(wildcard $(UD_ROOT)\\", v, "\\*.h) ")
    end
    f:write("\n\n")

    f:write("resource_files = ")
    for i, v in ipairs(resources) do
        f:write("\\\n", v, " ")
    end
    f:write("\n\n")
    
    if prec_header ~= 0 then
        f:write("prec.h.gch: prec.h\n")
        -- to keep things simple let's use single prec.h file and
        -- include it to *.cpp files only in case of coexistence of
        -- *.cpp and *.c files
        if cpp_files ~= 0 then
            f:write("\t$(compile_cpp_header)")
        else
            f:write("\t$(compile_c_header)")
        end
        f:write("\n\n")
    end
    
    for i, v in ipairs(src) do
        local use_prec_header = 0
        if prec_header ~= 0 then
            -- to keep things simple let's use single prec.h file and
            -- include it to *.cpp files only in case of coexistence of
            -- *.cpp and *.c files
            if string.find(v,"%.cpp$") or cpp_files == 0 then
                use_prec_header = 1
            end
        end

        local outfile = "$(OBJPATH)\\" .. string.gsub(v,"%.c(.-)$","%.o")

        f:write(outfile, ": ", v, " $(header_files)")
        
        if use_prec_header ~= 0 then
            f:write(" prec.h.gch")
        end
        
        if string.find(v,"%.cpp$") then
            f:write("\n\t$(compile_cpp_source)\n\n")
        else
            f:write("\n\t$(compile_c_source)\n\n")
        end
    end

    for i, v in ipairs(rc) do
        local outfile = "$(OBJPATH)\\" .. string.gsub(v,"%.rc","%.res")
        f:write(outfile, ": ", v, " $(header_files) $(resource_files)")
        f:write("\n\t$(compile_resource)\n\n")
    end

    f:write("SRC_OBJS =")
    for i, v in ipairs(src) do
        f:write(" $(OBJPATH)\\" .. string.gsub(v,"%.c(.-)$","%.o"))
    end
    f:write("\n\n")

    f:write("RSRC_OBJS =")
    for i, v in ipairs(rc) do
        f:write(" $(OBJPATH)\\" .. string.gsub(v,"%.rc","%.res"))
    end
    f:write("\n\n")

    -- for safety native executables should never depend on anything other
    -- than ntdll library, otherwise they might mess up the Windows boot
    -- process in case of accidental removal of libraries they depend on
    f:write("EXT_OBJS =")
    if target_type == "native" then
        f:write(" $(UD_ROOT)\\obj\\udefrag\\*.o")
        f:write(" $(UD_ROOT)\\obj\\zenwinx\\*.o")
    end
    f:write("\n\n")
    
    f:write("$(TARGET): $(SRC_OBJS) $(RSRC_OBJS)\n")

    -- to build native executables we have to rename a couple
    -- of object files to avoid duplicated definitions of symbols
    if target_type == "native" then
        f:write("\t@cmd /c move /Y $(UD_ROOT)\\obj\\udefrag\\entry.o")
        f:write(" $(UD_ROOT)\\obj\\udefrag\\entry.tmp\n")
        f:write("\t@cmd /c move /Y $(UD_ROOT)\\obj\\udefrag\\int64.o")
        f:write(" $(UD_ROOT)\\obj\\udefrag\\int64.tmp\n")
    end

    f:write("\t$(build_target)\n")

    -- restore renamed object files
    if target_type == "native" then
        f:write("\t@cmd /c move /Y $(UD_ROOT)\\obj\\udefrag\\entry.tmp")
        f:write(" $(UD_ROOT)\\obj\\udefrag\\entry.o\n")
        f:write("\t@cmd /c move /Y $(UD_ROOT)\\obj\\udefrag\\int64.tmp")
        f:write(" $(UD_ROOT)\\obj\\udefrag\\int64.o\n")
    end

    if target_type == "dll" then
        -- produce interface library from .def file
        f:write("\t$(build_library)\n")
    end
    
    f:close()
end

-- frontend
input_filename = arg[1]
assert(input_filename,"File name must be specified!")
print(input_filename .. ": preparing makefile generation...")

dofile(input_filename)

if os.execute("cmd.exe /C dir /S /B >project_files") ~= 0 then
    error("Cannot get directory listing!")
end
f = assert(io.open("project_files","rt"))
files = {}
for line in f:lines() do
    table.insert(files,line)
end
f:close()
os.execute("cmd.exe /C del /Q project_files")
assert(files[1],"No project files found!")

-- search for prec.h file
f = io.open("prec.h","r")
if f then
    f:close()
    prec_header = 1
end

-- search for .def files
deffile, mingw_deffile = "", ""
for i, v in ipairs(files) do
    local i, j, def
    i, j, def = string.find(v,"^.*\\(.-)$")
    if not def then def = v end
    if string.find(def,"%.def$") then
        if string.find(def,"mingw%.def$") then
            mingw_deffile = def
        else
            deffile = def
        end
    end
end
if deffile == "" then deffile = mingw_deffile end
if mingw_deffile == "" then mingw_deffile = deffile end

-- setup src, rc and resources tables
for i, v in ipairs(files) do
    local i, j, name, p
    i, j, name = string.find(v,"^.*\\(.-)$")
    if not name then name = v end
    if string.find(name,"%.c$") then
        if name ~= "prec.c" then
            table.insert(src,name)
        end
    elseif string.find(name,"%.cpp$") then
        if name ~= "prec.cpp" then
            cpp_files = cpp_files + 1
            table.insert(src,name)
        end
    elseif string.find(name,"%.rc$") then
        table.insert(rc,name)
    end
    for i, p in ipairs(rsrc_patterns) do
        if string.find(v,p) then
            table.insert(resources,v)
            break
        end
    end
end

if target_type == "console" or target_type == "gui" or target_type == "native" then
    target_ext = "exe"
elseif target_type == "dll" then
    target_ext = "dll"
else
    error("Unknown target type: " .. target_type .. "!")
end
target_name = name .. "." .. target_ext

outpath = os.getenv("UD_ROOT") .. "\\bin"
libpath = os.getenv("UD_ROOT") .. "\\lib"
objpath = os.getenv("UD_ROOT") .. "\\obj\\" .. os.getenv("UD_MOD_FOLDER_NAME")

arch = "i386"

if os.getenv("AMD64") then
    arch = "amd64"
    outpath = outpath .. "\\amd64"
    libpath = libpath .. "\\amd64"
elseif os.getenv("IA64") then
    arch = "ia64"
    outpath = outpath .. "\\ia64"
    libpath = libpath .. "\\ia64"
end

if os.getenv("BUILD_ENV") == "winsdk" then
    print(input_filename .. ": winsdk build performing...\n")
    produce_sdk_makefile()

    -- select appropriate precompiled header
    if arch ~= "i386" then
        os.execute("cmd.exe /C move /Y prec.pch prec-i386.pch > nul 2>&1")
        os.execute("cmd.exe /C move /Y prec-" .. arch .. ".pch prec.pch > nul 2>&1")
    end

    result = os.execute(sdk_cmd)

    -- restore default precompiled header
    if arch ~= "i386" then
        os.execute("cmd.exe /C move /Y prec.pch prec-" .. arch .. ".pch > nul 2>&1")
        os.execute("cmd.exe /C move /Y prec-i386.pch prec.pch > nul 2>&1")
    end
elseif os.getenv("BUILD_ENV") == "mingw" then
    print(input_filename .. ": mingw build performing...\n")
    produce_mingw_makefile()
    result = os.execute(mingw_cmd)
elseif os.getenv("BUILD_ENV") == "mingw_x64" then
    -- NOTE: MinGW x64 compiler currently generates wrong
    -- code, therefore we cannot use it for real purposes
    print(input_filename .. ": mingw x64 build performing...\n")
    produce_mingw_makefile()

    -- select appropriate precompiled header
    os.execute("cmd.exe /C move /Y prec.h.gch prec-i386.h.gch > nul 2>&1")
    os.execute("cmd.exe /C move /Y prec-amd64.h.gch prec.h.gch > nul 2>&1")

    result = os.execute(mingw_cmd)

    -- restore default precompiled header
    os.execute("cmd.exe /C move /Y prec.h.gch prec-amd64.h.gch > nul 2>&1")
    os.execute("cmd.exe /C move /Y prec-i386.h.gch prec.h.gch > nul 2>&1")
else
    error("\%BUILD_ENV\% has wrong value: " .. os.getenv("BUILD_ENV") .. "!")
end

if result ~= 0 then
    error("Cannot build the target!")
end

print("\n" .. input_filename .. ": " .. os.getenv("BUILD_ENV") .. " build was successful\n")

-- uncomment to manually build one binary after another
-- os.execute("cmd.exe /C pause")
